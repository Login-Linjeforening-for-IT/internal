import fs from 'fs/promises'
import path from 'path'
import config from '#config'
import { exec } from 'child_process'
import { promisify } from 'util'
import { CronExpressionParser } from 'cron-parser'
import { formatSize } from '#utils/format.ts'
import { getBackupDir, getContainerEnv } from '#utils/backup/utils.ts'
import getPostgresContainers from '#utils/backup/containers.ts'
import type { FastifyReply, FastifyRequest } from 'fastify'

const execAsync = promisify(exec)

export default async function getBackupStats(_: FastifyRequest, res: FastifyReply) {
    try {
        const containers = await getPostgresContainers({ all: true })

        const nextBackup = (() => {
            try {
                return CronExpressionParser.parse(config.backup.schedule).next().toISOString()
            } catch { 
                return 'Invalid schedule'
            }
        })()

        const stats = await Promise.all(containers.map(async (container) => {
            const { id, name, status, project, workingDir } = container
            const info = {
                id,
                name,
                status,
                lastBackup: null as string | null,
                nextBackup,
                totalStorage: '0 B',
                dbSize: 'Unknown',
                error: null as string | null
            }

            if (!project || !workingDir) {
                return { ...info, error: 'Missing labels' }
            }

            try {
                const { DB, DB_USER, DB_PASSWORD } = await getContainerEnv(workingDir)

                if (!DB || !DB_USER || !DB_PASSWORD) {
                    info.error = 'Missing env vars'
                } else if (!status.startsWith('Up')) {
                    info.error = 'Container not running'
                }

                const backupDir = getBackupDir(project)
                const [dbSize, stats] = await Promise.all([
                    info.dbSize === 'Unknown'
                        ? execAsync(
                            `docker exec -e PGPASSWORD="${DB_PASSWORD}" ${id} psql -U "${DB_USER}" -d "${DB}" -t -c "SELECT pg_database_size('${DB}');"`
                        ).then(r => r.stdout.trim()).catch(() => 'Unknown')
                        : Promise.resolve(info.dbSize),
                    fs.readdir(backupDir).then(async files => {
                        const s = await Promise.all(
                            files.map(f => fs.stat(path.join(backupDir, f)
                        ).catch(() => null)))
                        return s.reduce(
                            (a, v) => v ? 
                            { size: a.size + v.size, time: Math.max(a.time, v.mtimeMs) } :
                                a, { size: 0, time: 0 }
                        )
                    }).catch(
                        () => (
                            { size: 0, time: 0 }
                        ))
                ])

                return {
                    ...info,
                    dbSize: isNaN(Number(dbSize)) ? dbSize : formatSize(Number(dbSize)),
                    totalStorage: formatSize(stats.size),
                    lastBackup: stats.time ? new Date(stats.time).toISOString() : null
                }
            } catch {
                return { ...info, dbSize: 'Error' }
            }
        }))

        res.send(stats)
    } catch (error) {
        res.status(500).send({ error: (error as Error).message })
    }
}
